// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/service_interface.proto

#ifndef PROTOBUF_proto_2fservice_5finterface_2eproto__INCLUDED
#define PROTOBUF_proto_2fservice_5finterface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

class AbstractData;
class Base;
class Connect;
class NetworkPacket;
class Node;
class Requirements;
class Response;
class Service;
class Stream;
class Time;

// ===================================================================

class Base : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Base) */ {
 public:
  Base();
  virtual ~Base();

  Base(const Base& from);

  inline Base& operator=(const Base& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Base& default_instance();

  void Swap(Base* other);

  // implements Message ----------------------------------------------

  inline Base* New() const { return New(NULL); }

  Base* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Base& from);
  void MergeFrom(const Base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Base* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message_type = 1;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 1;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // optional string message_data = 2;
  void clear_message_data();
  static const int kMessageDataFieldNumber = 2;
  const ::std::string& message_data() const;
  void set_message_data(const ::std::string& value);
  void set_message_data(const char* value);
  void set_message_data(const char* value, size_t size);
  ::std::string* mutable_message_data();
  ::std::string* release_message_data();
  void set_allocated_message_data(::std::string* message_data);

  // @@protoc_insertion_point(class_scope:Base)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  ::google::protobuf::internal::ArenaStringPtr message_data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Base* default_instance_;
};
// -------------------------------------------------------------------

class Requirements : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Requirements) */ {
 public:
  Requirements();
  virtual ~Requirements();

  Requirements(const Requirements& from);

  inline Requirements& operator=(const Requirements& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Requirements& default_instance();

  void Swap(Requirements* other);

  // implements Message ----------------------------------------------

  inline Requirements* New() const { return New(NULL); }

  Requirements* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Requirements& from);
  void MergeFrom(const Requirements& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Requirements* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Service services = 1;
  int services_size() const;
  void clear_services();
  static const int kServicesFieldNumber = 1;
  const ::Service& services(int index) const;
  ::Service* mutable_services(int index);
  ::Service* add_services();
  ::google::protobuf::RepeatedPtrField< ::Service >*
      mutable_services();
  const ::google::protobuf::RepeatedPtrField< ::Service >&
      services() const;

  // repeated .Stream streams = 2;
  int streams_size() const;
  void clear_streams();
  static const int kStreamsFieldNumber = 2;
  const ::Stream& streams(int index) const;
  ::Stream* mutable_streams(int index);
  ::Stream* add_streams();
  ::google::protobuf::RepeatedPtrField< ::Stream >*
      mutable_streams();
  const ::google::protobuf::RepeatedPtrField< ::Stream >&
      streams() const;

  // @@protoc_insertion_point(class_scope:Requirements)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Service > services_;
  ::google::protobuf::RepeatedPtrField< ::Stream > streams_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Requirements* default_instance_;
};
// -------------------------------------------------------------------

class Connect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Connect) */ {
 public:
  Connect();
  virtual ~Connect();

  Connect(const Connect& from);

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connect& default_instance();

  void Swap(Connect* other);

  // implements Message ----------------------------------------------

  inline Connect* New() const { return New(NULL); }

  Connect* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Connect& from);
  void MergeFrom(const Connect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Connect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string federation_name = 1;
  void clear_federation_name();
  static const int kFederationNameFieldNumber = 1;
  const ::std::string& federation_name() const;
  void set_federation_name(const ::std::string& value);
  void set_federation_name(const char* value);
  void set_federation_name(const char* value, size_t size);
  ::std::string* mutable_federation_name();
  ::std::string* release_federation_name();
  void set_allocated_federation_name(::std::string* federation_name);

  // optional bytes auth_data = 2;
  void clear_auth_data();
  static const int kAuthDataFieldNumber = 2;
  const ::std::string& auth_data() const;
  void set_auth_data(const ::std::string& value);
  void set_auth_data(const char* value);
  void set_auth_data(const void* value, size_t size);
  ::std::string* mutable_auth_data();
  ::std::string* release_auth_data();
  void set_allocated_auth_data(::std::string* auth_data);

  // optional .Requirements requirements = 3;
  bool has_requirements() const;
  void clear_requirements();
  static const int kRequirementsFieldNumber = 3;
  const ::Requirements& requirements() const;
  ::Requirements* mutable_requirements();
  ::Requirements* release_requirements();
  void set_allocated_requirements(::Requirements* requirements);

  // optional string connection = 4;
  void clear_connection();
  static const int kConnectionFieldNumber = 4;
  const ::std::string& connection() const;
  void set_connection(const ::std::string& value);
  void set_connection(const char* value);
  void set_connection(const char* value, size_t size);
  ::std::string* mutable_connection();
  ::std::string* release_connection();
  void set_allocated_connection(::std::string* connection);

  // @@protoc_insertion_point(class_scope:Connect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr federation_name_;
  ::google::protobuf::internal::ArenaStringPtr auth_data_;
  ::Requirements* requirements_;
  ::google::protobuf::internal::ArenaStringPtr connection_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Connect* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int64 code() const;
  void set_code(::google::protobuf::int64 value);

  // optional string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 code_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  inline Node* New() const { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  void Swap(Time* other);

  // implements Message ----------------------------------------------

  inline Time* New() const { return New(NULL); }

  Time* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double seconds = 1;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  double seconds() const;
  void set_seconds(double value);

  // @@protoc_insertion_point(class_scope:Time)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  double seconds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Time* default_instance_;
};
// -------------------------------------------------------------------

class NetworkPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NetworkPacket) */ {
 public:
  NetworkPacket();
  virtual ~NetworkPacket();

  NetworkPacket(const NetworkPacket& from);

  inline NetworkPacket& operator=(const NetworkPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkPacket& default_instance();

  void Swap(NetworkPacket* other);

  // implements Message ----------------------------------------------

  inline NetworkPacket* New() const { return New(NULL); }

  NetworkPacket* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkPacket& from);
  void MergeFrom(const NetworkPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetworkPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Node destinations = 1;
  int destinations_size() const;
  void clear_destinations();
  static const int kDestinationsFieldNumber = 1;
  const ::Node& destinations(int index) const;
  ::Node* mutable_destinations(int index);
  ::Node* add_destinations();
  ::google::protobuf::RepeatedPtrField< ::Node >*
      mutable_destinations();
  const ::google::protobuf::RepeatedPtrField< ::Node >&
      destinations() const;

  // optional bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:NetworkPacket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Node > destinations_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static NetworkPacket* default_instance_;
};
// -------------------------------------------------------------------

class AbstractData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AbstractData) */ {
 public:
  AbstractData();
  virtual ~AbstractData();

  AbstractData(const AbstractData& from);

  inline AbstractData& operator=(const AbstractData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbstractData& default_instance();

  void Swap(AbstractData* other);

  // implements Message ----------------------------------------------

  inline AbstractData* New() const { return New(NULL); }

  AbstractData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AbstractData& from);
  void MergeFrom(const AbstractData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AbstractData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:AbstractData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static AbstractData* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  inline Stream* New() const { return New(NULL); }

  Stream* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Node source = 1;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  const ::Node& source() const;
  ::Node* mutable_source();
  ::Node* release_source();
  void set_allocated_source(::Node* source);

  // optional .AbstractData data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::AbstractData& data() const;
  ::AbstractData* mutable_data();
  ::AbstractData* release_data();
  void set_allocated_data(::AbstractData* data);

  // optional .Time interval = 3;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 3;
  const ::Time& interval() const;
  ::Time* mutable_interval();
  ::Time* release_interval();
  void set_allocated_interval(::Time* interval);

  // @@protoc_insertion_point(class_scope:Stream)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::Node* source_;
  ::AbstractData* data_;
  ::Time* interval_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Service) */ {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  void Swap(Service* other);

  // implements Message ----------------------------------------------

  inline Service* New() const { return New(NULL); }

  Service* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Service* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Node destinations = 1;
  int destinations_size() const;
  void clear_destinations();
  static const int kDestinationsFieldNumber = 1;
  const ::Node& destinations(int index) const;
  ::Node* mutable_destinations(int index);
  ::Node* add_destinations();
  ::google::protobuf::RepeatedPtrField< ::Node >*
      mutable_destinations();
  const ::google::protobuf::RepeatedPtrField< ::Node >&
      destinations() const;

  // optional .AbstractData command = 2;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  const ::AbstractData& command() const;
  ::AbstractData* mutable_command();
  ::AbstractData* release_command();
  void set_allocated_command(::AbstractData* command);

  // @@protoc_insertion_point(class_scope:Service)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::Node > destinations_;
  ::AbstractData* command_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_AssignDesc_proto_2fservice_5finterface_2eproto();
  friend void protobuf_ShutdownFile_proto_2fservice_5finterface_2eproto();

  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Base

// optional string message_type = 1;
inline void Base::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Base::message_type() const {
  // @@protoc_insertion_point(field_get:Base.message_type)
  return message_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Base::set_message_type(const ::std::string& value) {
  
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Base.message_type)
}
inline void Base::set_message_type(const char* value) {
  
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Base.message_type)
}
inline void Base::set_message_type(const char* value, size_t size) {
  
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Base.message_type)
}
inline ::std::string* Base::mutable_message_type() {
  
  // @@protoc_insertion_point(field_mutable:Base.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Base::release_message_type() {
  // @@protoc_insertion_point(field_release:Base.message_type)
  
  return message_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Base::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    
  } else {
    
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:Base.message_type)
}

// optional string message_data = 2;
inline void Base::clear_message_data() {
  message_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Base::message_data() const {
  // @@protoc_insertion_point(field_get:Base.message_data)
  return message_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Base::set_message_data(const ::std::string& value) {
  
  message_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Base.message_data)
}
inline void Base::set_message_data(const char* value) {
  
  message_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Base.message_data)
}
inline void Base::set_message_data(const char* value, size_t size) {
  
  message_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Base.message_data)
}
inline ::std::string* Base::mutable_message_data() {
  
  // @@protoc_insertion_point(field_mutable:Base.message_data)
  return message_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Base::release_message_data() {
  // @@protoc_insertion_point(field_release:Base.message_data)
  
  return message_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Base::set_allocated_message_data(::std::string* message_data) {
  if (message_data != NULL) {
    
  } else {
    
  }
  message_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_data);
  // @@protoc_insertion_point(field_set_allocated:Base.message_data)
}

// -------------------------------------------------------------------

// Requirements

// repeated .Service services = 1;
inline int Requirements::services_size() const {
  return services_.size();
}
inline void Requirements::clear_services() {
  services_.Clear();
}
inline const ::Service& Requirements::services(int index) const {
  // @@protoc_insertion_point(field_get:Requirements.services)
  return services_.Get(index);
}
inline ::Service* Requirements::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:Requirements.services)
  return services_.Mutable(index);
}
inline ::Service* Requirements::add_services() {
  // @@protoc_insertion_point(field_add:Requirements.services)
  return services_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Service >*
Requirements::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:Requirements.services)
  return &services_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Service >&
Requirements::services() const {
  // @@protoc_insertion_point(field_list:Requirements.services)
  return services_;
}

// repeated .Stream streams = 2;
inline int Requirements::streams_size() const {
  return streams_.size();
}
inline void Requirements::clear_streams() {
  streams_.Clear();
}
inline const ::Stream& Requirements::streams(int index) const {
  // @@protoc_insertion_point(field_get:Requirements.streams)
  return streams_.Get(index);
}
inline ::Stream* Requirements::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:Requirements.streams)
  return streams_.Mutable(index);
}
inline ::Stream* Requirements::add_streams() {
  // @@protoc_insertion_point(field_add:Requirements.streams)
  return streams_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Stream >*
Requirements::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:Requirements.streams)
  return &streams_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Stream >&
Requirements::streams() const {
  // @@protoc_insertion_point(field_list:Requirements.streams)
  return streams_;
}

// -------------------------------------------------------------------

// Connect

// optional string federation_name = 1;
inline void Connect::clear_federation_name() {
  federation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connect::federation_name() const {
  // @@protoc_insertion_point(field_get:Connect.federation_name)
  return federation_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connect::set_federation_name(const ::std::string& value) {
  
  federation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Connect.federation_name)
}
inline void Connect::set_federation_name(const char* value) {
  
  federation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Connect.federation_name)
}
inline void Connect::set_federation_name(const char* value, size_t size) {
  
  federation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Connect.federation_name)
}
inline ::std::string* Connect::mutable_federation_name() {
  
  // @@protoc_insertion_point(field_mutable:Connect.federation_name)
  return federation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connect::release_federation_name() {
  // @@protoc_insertion_point(field_release:Connect.federation_name)
  
  return federation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connect::set_allocated_federation_name(::std::string* federation_name) {
  if (federation_name != NULL) {
    
  } else {
    
  }
  federation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), federation_name);
  // @@protoc_insertion_point(field_set_allocated:Connect.federation_name)
}

// optional bytes auth_data = 2;
inline void Connect::clear_auth_data() {
  auth_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connect::auth_data() const {
  // @@protoc_insertion_point(field_get:Connect.auth_data)
  return auth_data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connect::set_auth_data(const ::std::string& value) {
  
  auth_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Connect.auth_data)
}
inline void Connect::set_auth_data(const char* value) {
  
  auth_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Connect.auth_data)
}
inline void Connect::set_auth_data(const void* value, size_t size) {
  
  auth_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Connect.auth_data)
}
inline ::std::string* Connect::mutable_auth_data() {
  
  // @@protoc_insertion_point(field_mutable:Connect.auth_data)
  return auth_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connect::release_auth_data() {
  // @@protoc_insertion_point(field_release:Connect.auth_data)
  
  return auth_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connect::set_allocated_auth_data(::std::string* auth_data) {
  if (auth_data != NULL) {
    
  } else {
    
  }
  auth_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth_data);
  // @@protoc_insertion_point(field_set_allocated:Connect.auth_data)
}

// optional .Requirements requirements = 3;
inline bool Connect::has_requirements() const {
  return !_is_default_instance_ && requirements_ != NULL;
}
inline void Connect::clear_requirements() {
  if (GetArenaNoVirtual() == NULL && requirements_ != NULL) delete requirements_;
  requirements_ = NULL;
}
inline const ::Requirements& Connect::requirements() const {
  // @@protoc_insertion_point(field_get:Connect.requirements)
  return requirements_ != NULL ? *requirements_ : *default_instance_->requirements_;
}
inline ::Requirements* Connect::mutable_requirements() {
  
  if (requirements_ == NULL) {
    requirements_ = new ::Requirements;
  }
  // @@protoc_insertion_point(field_mutable:Connect.requirements)
  return requirements_;
}
inline ::Requirements* Connect::release_requirements() {
  // @@protoc_insertion_point(field_release:Connect.requirements)
  
  ::Requirements* temp = requirements_;
  requirements_ = NULL;
  return temp;
}
inline void Connect::set_allocated_requirements(::Requirements* requirements) {
  delete requirements_;
  requirements_ = requirements;
  if (requirements) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Connect.requirements)
}

// optional string connection = 4;
inline void Connect::clear_connection() {
  connection_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connect::connection() const {
  // @@protoc_insertion_point(field_get:Connect.connection)
  return connection_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connect::set_connection(const ::std::string& value) {
  
  connection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Connect.connection)
}
inline void Connect::set_connection(const char* value) {
  
  connection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Connect.connection)
}
inline void Connect::set_connection(const char* value, size_t size) {
  
  connection_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Connect.connection)
}
inline ::std::string* Connect::mutable_connection() {
  
  // @@protoc_insertion_point(field_mutable:Connect.connection)
  return connection_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connect::release_connection() {
  // @@protoc_insertion_point(field_release:Connect.connection)
  
  return connection_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connect::set_allocated_connection(::std::string* connection) {
  if (connection != NULL) {
    
  } else {
    
  }
  connection_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), connection);
  // @@protoc_insertion_point(field_set_allocated:Connect.connection)
}

// -------------------------------------------------------------------

// Response

// optional int64 code = 1;
inline void Response::clear_code() {
  code_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Response::code() const {
  // @@protoc_insertion_point(field_get:Response.code)
  return code_;
}
inline void Response::set_code(::google::protobuf::int64 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:Response.code)
}

// optional string message = 2;
inline void Response::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::message() const {
  // @@protoc_insertion_point(field_get:Response.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Response.message)
}
inline void Response::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Response.message)
}
inline void Response::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Response.message)
}
inline ::std::string* Response::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:Response.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_message() {
  // @@protoc_insertion_point(field_release:Response.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:Response.message)
}

// optional bytes value = 3;
inline void Response::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::value() const {
  // @@protoc_insertion_point(field_get:Response.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Response.value)
}
inline void Response::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Response.value)
}
inline void Response::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Response.value)
}
inline ::std::string* Response::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:Response.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_value() {
  // @@protoc_insertion_point(field_release:Response.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:Response.value)
}

// -------------------------------------------------------------------

// Node

// optional string name = 1;
inline void Node::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:Node.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Node.name)
}
inline void Node::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Node.name)
}
inline ::std::string* Node::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Node.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:Node.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Node.name)
}

// optional string address = 2;
inline void Node::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::address() const {
  // @@protoc_insertion_point(field_get:Node.address)
  return address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Node.address)
}
inline void Node::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Node.address)
}
inline void Node::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Node.address)
}
inline ::std::string* Node::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:Node.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_address() {
  // @@protoc_insertion_point(field_release:Node.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:Node.address)
}

// -------------------------------------------------------------------

// Time

// optional double seconds = 1;
inline void Time::clear_seconds() {
  seconds_ = 0;
}
inline double Time::seconds() const {
  // @@protoc_insertion_point(field_get:Time.seconds)
  return seconds_;
}
inline void Time::set_seconds(double value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:Time.seconds)
}

// -------------------------------------------------------------------

// NetworkPacket

// repeated .Node destinations = 1;
inline int NetworkPacket::destinations_size() const {
  return destinations_.size();
}
inline void NetworkPacket::clear_destinations() {
  destinations_.Clear();
}
inline const ::Node& NetworkPacket::destinations(int index) const {
  // @@protoc_insertion_point(field_get:NetworkPacket.destinations)
  return destinations_.Get(index);
}
inline ::Node* NetworkPacket::mutable_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkPacket.destinations)
  return destinations_.Mutable(index);
}
inline ::Node* NetworkPacket::add_destinations() {
  // @@protoc_insertion_point(field_add:NetworkPacket.destinations)
  return destinations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Node >*
NetworkPacket::mutable_destinations() {
  // @@protoc_insertion_point(field_mutable_list:NetworkPacket.destinations)
  return &destinations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Node >&
NetworkPacket::destinations() const {
  // @@protoc_insertion_point(field_list:NetworkPacket.destinations)
  return destinations_;
}

// optional bytes data = 2;
inline void NetworkPacket::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NetworkPacket::data() const {
  // @@protoc_insertion_point(field_get:NetworkPacket.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkPacket::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NetworkPacket.data)
}
inline void NetworkPacket::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NetworkPacket.data)
}
inline void NetworkPacket::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NetworkPacket.data)
}
inline ::std::string* NetworkPacket::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:NetworkPacket.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetworkPacket::release_data() {
  // @@protoc_insertion_point(field_release:NetworkPacket.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetworkPacket::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:NetworkPacket.data)
}

// -------------------------------------------------------------------

// AbstractData

// optional string name = 1;
inline void AbstractData::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AbstractData::name() const {
  // @@protoc_insertion_point(field_get:AbstractData.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbstractData::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AbstractData.name)
}
inline void AbstractData::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AbstractData.name)
}
inline void AbstractData::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AbstractData.name)
}
inline ::std::string* AbstractData::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:AbstractData.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbstractData::release_name() {
  // @@protoc_insertion_point(field_release:AbstractData.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbstractData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:AbstractData.name)
}

// optional string type = 2;
inline void AbstractData::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AbstractData::type() const {
  // @@protoc_insertion_point(field_get:AbstractData.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbstractData::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AbstractData.type)
}
inline void AbstractData::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AbstractData.type)
}
inline void AbstractData::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AbstractData.type)
}
inline ::std::string* AbstractData::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:AbstractData.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbstractData::release_type() {
  // @@protoc_insertion_point(field_release:AbstractData.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbstractData::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:AbstractData.type)
}

// optional bytes data = 3;
inline void AbstractData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AbstractData::data() const {
  // @@protoc_insertion_point(field_get:AbstractData.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbstractData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AbstractData.data)
}
inline void AbstractData::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AbstractData.data)
}
inline void AbstractData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AbstractData.data)
}
inline ::std::string* AbstractData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:AbstractData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AbstractData::release_data() {
  // @@protoc_insertion_point(field_release:AbstractData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AbstractData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:AbstractData.data)
}

// -------------------------------------------------------------------

// Stream

// optional .Node source = 1;
inline bool Stream::has_source() const {
  return !_is_default_instance_ && source_ != NULL;
}
inline void Stream::clear_source() {
  if (GetArenaNoVirtual() == NULL && source_ != NULL) delete source_;
  source_ = NULL;
}
inline const ::Node& Stream::source() const {
  // @@protoc_insertion_point(field_get:Stream.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::Node* Stream::mutable_source() {
  
  if (source_ == NULL) {
    source_ = new ::Node;
  }
  // @@protoc_insertion_point(field_mutable:Stream.source)
  return source_;
}
inline ::Node* Stream::release_source() {
  // @@protoc_insertion_point(field_release:Stream.source)
  
  ::Node* temp = source_;
  source_ = NULL;
  return temp;
}
inline void Stream::set_allocated_source(::Node* source) {
  delete source_;
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Stream.source)
}

// optional .AbstractData data = 2;
inline bool Stream::has_data() const {
  return !_is_default_instance_ && data_ != NULL;
}
inline void Stream::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) delete data_;
  data_ = NULL;
}
inline const ::AbstractData& Stream::data() const {
  // @@protoc_insertion_point(field_get:Stream.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::AbstractData* Stream::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::AbstractData;
  }
  // @@protoc_insertion_point(field_mutable:Stream.data)
  return data_;
}
inline ::AbstractData* Stream::release_data() {
  // @@protoc_insertion_point(field_release:Stream.data)
  
  ::AbstractData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Stream::set_allocated_data(::AbstractData* data) {
  delete data_;
  data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Stream.data)
}

// optional .Time interval = 3;
inline bool Stream::has_interval() const {
  return !_is_default_instance_ && interval_ != NULL;
}
inline void Stream::clear_interval() {
  if (GetArenaNoVirtual() == NULL && interval_ != NULL) delete interval_;
  interval_ = NULL;
}
inline const ::Time& Stream::interval() const {
  // @@protoc_insertion_point(field_get:Stream.interval)
  return interval_ != NULL ? *interval_ : *default_instance_->interval_;
}
inline ::Time* Stream::mutable_interval() {
  
  if (interval_ == NULL) {
    interval_ = new ::Time;
  }
  // @@protoc_insertion_point(field_mutable:Stream.interval)
  return interval_;
}
inline ::Time* Stream::release_interval() {
  // @@protoc_insertion_point(field_release:Stream.interval)
  
  ::Time* temp = interval_;
  interval_ = NULL;
  return temp;
}
inline void Stream::set_allocated_interval(::Time* interval) {
  delete interval_;
  interval_ = interval;
  if (interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Stream.interval)
}

// -------------------------------------------------------------------

// Service

// repeated .Node destinations = 1;
inline int Service::destinations_size() const {
  return destinations_.size();
}
inline void Service::clear_destinations() {
  destinations_.Clear();
}
inline const ::Node& Service::destinations(int index) const {
  // @@protoc_insertion_point(field_get:Service.destinations)
  return destinations_.Get(index);
}
inline ::Node* Service::mutable_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:Service.destinations)
  return destinations_.Mutable(index);
}
inline ::Node* Service::add_destinations() {
  // @@protoc_insertion_point(field_add:Service.destinations)
  return destinations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Node >*
Service::mutable_destinations() {
  // @@protoc_insertion_point(field_mutable_list:Service.destinations)
  return &destinations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Node >&
Service::destinations() const {
  // @@protoc_insertion_point(field_list:Service.destinations)
  return destinations_;
}

// optional .AbstractData command = 2;
inline bool Service::has_command() const {
  return !_is_default_instance_ && command_ != NULL;
}
inline void Service::clear_command() {
  if (GetArenaNoVirtual() == NULL && command_ != NULL) delete command_;
  command_ = NULL;
}
inline const ::AbstractData& Service::command() const {
  // @@protoc_insertion_point(field_get:Service.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::AbstractData* Service::mutable_command() {
  
  if (command_ == NULL) {
    command_ = new ::AbstractData;
  }
  // @@protoc_insertion_point(field_mutable:Service.command)
  return command_;
}
inline ::AbstractData* Service::release_command() {
  // @@protoc_insertion_point(field_release:Service.command)
  
  ::AbstractData* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Service::set_allocated_command(::AbstractData* command) {
  delete command_;
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Service.command)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fservice_5finterface_2eproto__INCLUDED
